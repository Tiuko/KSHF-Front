{
  "version": 3,
  "sources": ["../../p-defer/index.js", "../../map-age-cleaner/dist/index.js", "../../mimic-fn/index.js", "../../mem/dist/index.js"],
  "sourcesContent": ["'use strict';\nmodule.exports = () => {\n\tconst ret = {};\n\n\tret.promise = new Promise((resolve, reject) => {\n\t\tret.resolve = resolve;\n\t\tret.reject = reject;\n\t});\n\n\treturn ret;\n};\n", "\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\nfunction mapAgeCleaner(map, property = 'maxAge') {\n    let processingKey;\n    let processingTimer;\n    let processingDeferred;\n    const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n        if (processingKey !== undefined) {\n            // If we are already processing an item, we can safely exit\n            return;\n        }\n        const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {\n            processingDeferred = p_defer_1.default();\n            const delay = item[1][property] - Date.now();\n            if (delay <= 0) {\n                // Remove the item immediately if the delay is equal to or below 0\n                map.delete(item[0]);\n                processingDeferred.resolve();\n                return;\n            }\n            // Keep track of the current processed key\n            processingKey = item[0];\n            processingTimer = setTimeout(() => {\n                // Remove the item when the timeout fires\n                map.delete(item[0]);\n                if (processingDeferred) {\n                    processingDeferred.resolve();\n                }\n            }, delay);\n            // tslint:disable-next-line:strict-type-predicates\n            if (typeof processingTimer.unref === 'function') {\n                // Don't hold up the process from exiting\n                processingTimer.unref();\n            }\n            return processingDeferred.promise;\n        });\n        try {\n            for (const entry of map) {\n                yield setupTimer(entry);\n            }\n        }\n        catch (_a) {\n            // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n        }\n        processingKey = undefined;\n    });\n    const reset = () => {\n        processingKey = undefined;\n        if (processingTimer !== undefined) {\n            clearTimeout(processingTimer);\n            processingTimer = undefined;\n        }\n        if (processingDeferred !== undefined) { // tslint:disable-line:early-exit\n            processingDeferred.reject(undefined);\n            processingDeferred = undefined;\n        }\n    };\n    const originalSet = map.set.bind(map);\n    map.set = (key, value) => {\n        if (map.has(key)) {\n            // If the key already exist, remove it so we can add it back at the end of the map.\n            map.delete(key);\n        }\n        // Call the original `map.set`\n        const result = originalSet(key, value);\n        // If we are already processing a key and the key added is the current processed key, stop processing it\n        if (processingKey && processingKey === key) {\n            reset();\n        }\n        // Always run the cleanup method in case it wasn't started yet\n        cleanup(); // tslint:disable-line:no-floating-promises\n        return result;\n    };\n    cleanup(); // tslint:disable-line:no-floating-promises\n    return map;\n}\nexports.default = mapAgeCleaner;\n// Add support for CJS\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;\n", "const copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n// - one its descriptors is changed\n// - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nexport default function mimicFunction(to, from, {ignoreNonConfigurable = false} = {}) {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n}\n", "import mimicFn from 'mimic-fn';\nimport mapAgeCleaner from 'map-age-cleaner';\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem from 'mem';\n\nlet index = 0;\nconst counter = () => ++index;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same argument\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nexport default function mem(fn, { cacheKey, cache = new Map(), maxAge, } = {}) {\n    if (typeof maxAge === 'number') {\n        mapAgeCleaner(cache);\n    }\n    const memoized = function (...arguments_) {\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n        const cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem.data; // eslint-disable-line @typescript-eslint/no-unsafe-return\n        }\n        const result = fn.apply(this, arguments_);\n        cache.set(key, {\n            data: result,\n            maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY,\n        });\n        return result; // eslint-disable-line @typescript-eslint/no-unsafe-return\n    };\n    mimicFn(memoized, fn, {\n        ignoreNonConfigurable: true,\n    });\n    cacheStore.set(memoized, cache);\n    return memoized;\n}\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport {memDecorator} from 'mem';\n\nclass Example {\n    index = 0\n\n    @memDecorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @memDecorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nexport function memDecorator(options = {}) {\n    const instanceMap = new WeakMap();\n    return (target, propertyKey, descriptor) => {\n        const input = target[propertyKey]; // eslint-disable-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        if (typeof input !== 'function') {\n            throw new TypeError('The decorated value must be a function');\n        }\n        delete descriptor.value;\n        delete descriptor.writable;\n        descriptor.get = function () {\n            if (!instanceMap.has(this)) {\n                const value = mem(input, options);\n                instanceMap.set(this, value);\n                return value;\n            }\n            return instanceMap.get(this);\n        };\n    };\n}\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\nexport function memClear(fn) {\n    const cache = cacheStore.get(fn);\n    if (!cache) {\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\n    }\n    if (typeof cache.clear !== 'function') {\n        throw new TypeError('The cache Map can\\'t be cleared!');\n    }\n    cache.clear();\n}\n"],
  "mappings": "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",
  "names": ["resolve", "mapAgeCleaner", "mapAgeCleaner"]
}
